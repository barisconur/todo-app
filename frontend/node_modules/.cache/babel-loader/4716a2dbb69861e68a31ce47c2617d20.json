{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction selectInputText(element) {\n  element.setSelectionRange(0, element.value.length);\n}\n\nvar InlineEdit = function (_React$Component) {\n  _inherits(InlineEdit, _React$Component);\n\n  function InlineEdit() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, InlineEdit);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = InlineEdit.__proto__ || Object.getPrototypeOf(InlineEdit)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      editing: _this.props.editing,\n      text: _this.props.text,\n      minLength: _this.props.minLength,\n      maxLength: _this.props.maxLength\n    }, _this.startEditing = function (e) {\n      if (_this.props.stopPropagation) {\n        e.stopPropagation();\n      }\n\n      _this.setState({\n        editing: true,\n        text: _this.props.text\n      });\n    }, _this.finishEditing = function () {\n      if (_this.isInputValid(_this.state.text) && _this.props.text != _this.state.text) {\n        _this.commitEditing();\n      } else if (_this.props.text === _this.state.text || !_this.isInputValid(_this.state.text)) {\n        _this.cancelEditing();\n      }\n    }, _this.cancelEditing = function () {\n      _this.setState({\n        editing: false,\n        text: _this.props.text\n      });\n    }, _this.commitEditing = function () {\n      _this.setState({\n        editing: false,\n        text: _this.state.text\n      });\n\n      var newProp = {};\n      newProp[_this.props.paramName] = _this.state.text;\n\n      _this.props.change(newProp);\n    }, _this.clickWhenEditing = function (e) {\n      if (_this.props.stopPropagation) {\n        e.stopPropagation();\n      }\n    }, _this.isInputValid = function (text) {\n      return text.length >= _this.state.minLength && text.length <= _this.state.maxLength;\n    }, _this.keyDown = function (event) {\n      if (event.keyCode === 13) {\n        _this.finishEditing();\n      } else if (event.keyCode === 27) {\n        _this.cancelEditing();\n      }\n    }, _this.textChanged = function (event) {\n      _this.setState({\n        text: event.target.value.trim()\n      });\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(InlineEdit, [{\n    key: 'componentWillMount',\n    value: function componentWillMount() {\n      this.isInputValid = this.props.validate || this.isInputValid; // Warn about deprecated elements\n\n      if (this.props.element) {\n        console.warn('`element` prop is deprecated: instead pass editingElement or staticElement to InlineEdit component');\n      }\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var isTextChanged = nextProps.text !== this.props.text;\n      var isEditingChanged = nextProps.editing !== this.props.editing;\n      var nextState = {};\n\n      if (isTextChanged) {\n        nextState.text = nextProps.text;\n      }\n\n      if (isEditingChanged) {\n        nextState.editing = nextProps.editing;\n      }\n\n      if (isTextChanged || isEditingChanged) {\n        this.setState(nextState);\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var inputElem = _reactDom2.default.findDOMNode(this.refs.input);\n\n      if (this.state.editing && !prevState.editing) {\n        inputElem.focus();\n        selectInputText(inputElem);\n      } else if (this.state.editing && prevProps.text != this.props.text) {\n        this.finishEditing();\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      if (this.props.isDisabled) {\n        var Element = this.props.element || this.props.staticElement;\n        return _react2.default.createElement(Element, {\n          className: this.props.className,\n          style: this.props.style\n        }, this.state.text || this.props.placeholder);\n      } else if (!this.state.editing) {\n        var _Element = this.props.element || this.props.staticElement;\n\n        return _react2.default.createElement(_Element, {\n          className: this.props.className,\n          onClick: this.startEditing,\n          tabIndex: this.props.tabIndex,\n          style: this.props.style\n        }, this.state.text || this.props.placeholder);\n      } else {\n        var _Element2 = this.props.element || this.props.editingElement;\n\n        return _react2.default.createElement(_Element2, {\n          onClick: this.clickWhenEditing,\n          onKeyDown: this.keyDown,\n          onBlur: this.finishEditing,\n          className: this.props.activeClassName,\n          placeholder: this.props.placeholder,\n          defaultValue: this.state.text,\n          onChange: this.textChanged,\n          style: this.props.style,\n          ref: 'input'\n        });\n      }\n    }\n  }]);\n\n  return InlineEdit;\n}(_react2.default.Component);\n\nInlineEdit.propTypes = {\n  text: _propTypes2.default.string.isRequired,\n  paramName: _propTypes2.default.string.isRequired,\n  change: _propTypes2.default.func.isRequired,\n  placeholder: _propTypes2.default.string,\n  className: _propTypes2.default.string,\n  activeClassName: _propTypes2.default.string,\n  minLength: _propTypes2.default.number,\n  maxLength: _propTypes2.default.number,\n  validate: _propTypes2.default.func,\n  style: _propTypes2.default.object,\n  editingElement: _propTypes2.default.string,\n  staticElement: _propTypes2.default.string,\n  tabIndex: _propTypes2.default.number,\n  isDisabled: _propTypes2.default.bool,\n  editing: _propTypes2.default.bool\n};\nInlineEdit.defaultProps = {\n  minLength: 1,\n  maxLength: 256,\n  editingElement: 'input',\n  staticElement: 'span',\n  tabIndex: 0,\n  isDisabled: false,\n  editing: false\n};\nexports.default = InlineEdit;","map":null,"metadata":{},"sourceType":"script"}